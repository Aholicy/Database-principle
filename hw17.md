20337263俞泽斌-第十七章作业

17.15

a、事务的串行执行顺序可能为先T13后T14也可能相反

所以分成两个情况，并列表给出AB的值

先T13后T14

| 时间      | A    | B    |
| --------- | ---- | ---- |
| 初始      | 0    | 0    |
| T13执行后 | 0    | 1    |
| T14执行后 | 0    | 1    |

可以看到每个时间段都满足一致性要求（A或B为0）

先T14后T13

| 时间      | A    | B    |
| --------- | ---- | ---- |
| 初始      | 0    | 0    |
| T14执行后 | 1    | 0    |
| T13执行后 | 1    | 0    |

可以看到每个时间段都满足一致性要求（A或B为0）

所以可以得出对于这两个事务而言，串行执行均能够保证数据库的一致性  

b、一个不可串行化的例子

| 事务 T13                | 事务T14                 |
| ----------------------- | ----------------------- |
| read(A)                 |                         |
| read(B)                 |                         |
| if A = 0 then B = B + 1 |                         |
|                         | read(B)                 |
|                         | read(A)                 |
|                         | if B = 0 then A = A + 1 |
|                         | write(A)                |
| write(B)                |                         |

此时在事务T14被调入的时候事务T13还没有完成写入，所以读到的B的数据仍为0，所以会发生对于A的+1操作，最终使得AB均为1，违背了数控的一致性，并且与串行执行结果不同，不可串行化

c、不存在，由a得，串行执行的每一个结果都会满足数据库一致性要求，那么我们来看并行

假设T13先开始执行，因为是并行执行，所以T13不可能执行到最后一句write(B)操作，也就是说，T14被调入后得到的B值一定为上一次的值，即为0，所以一定会执行A=A+1操作，而A开始就已经被T13读入为0，所以也会执行B=B+1操作，其他顺序无论怎么排，必然最后写入的A与B均为1，不可能可以串行

同样假设T14先开始执行，这样B的值0首先被T14读入，而因为是并行执行，所以T14不能在T13进入前执行完write（A）操作，所以T13得到的A值也为0，所以最后的A和B还是都为1，违反一致性操作，不能串行。